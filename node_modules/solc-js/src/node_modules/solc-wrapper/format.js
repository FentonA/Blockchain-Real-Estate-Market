// @TODO: map stuff from the structure of old compilers to the new compiler

/* IDEAL STRUCTURE:
  @TODO: specify by example

  {
    name: 'AwardToken',
    abi: ...
    ...
  }

*/

module.exports = format

function format ({ version, url }, data) {
  console.log(version)
  console.log(Object.keys(data.contracts).reduce((agg, name) =>{
    agg[name] = Object.keys(data.contracts[name])
    return agg
  },{}))

  if (~version.indexOf('v0.5.')) {
    console.log('using 0.5+')
  }
  else if (~version.indexOf('v0.4.')) {
    console.log('using 0.4+')
  }

  var R = /^(.*):(\d+):(\d+):(.*):/

  return Object.keys(data.contracts).map(name => {
    var {
      interface: abi,
      bytecode,
      metadata,
      functionHashes,
      gasEstimates,
      assembly,
      opcodes,
      runtimeBytecode,
      srcmap,
      srcmapRuntime
    } = data.contracts[name]
    metadata = JSON.parse(metadata)
    const sources = {
      sourcecode: metadata.sources[''],
      compilationTarget: metadata.settings.compilationTarget[''],
      remappings: metadata.settings.remappings,
      libraries: metadata.settings.libraries,
      sourcelist: data.sourceList,
    }
    const compile = {
      language: metadata.language.toLowerCase(),
      version: version,
      url: url,
      evmVersion: metadata.settings.evmVersion,
      optimizer: metadata.settings.optimizer.enabled,
      runs: metadata.settings.optimizer.runs,
    }
    var compilation = {
      name: name.substring(1),
      abi: abi,
      sources: sources,
      compiler: compile,
      assembly: { assembly, opcodes },
      binary: {
        bytecodes: { bytecode, runtimeBytecode },
        sourcemap: { srcmap, srcmapRuntime },
      },
      metadata: {
        ast: data.sources[''].AST,
        devdoc: metadata.output.devdoc,
        userdoc: metadata.output.userdoc,
        functionHashes,
        gasEstimates,
        analysis: (() => {
          var result = { warnings: [], others: [] }
          for (var error in data.errors) {
            var message = data.errors[error]
            var type = R.exec(message)[4].trim().toLowerCase()
            ;(result[type] || (result[type] = [])).push(message)
          }
          return result
        })()
      },
    }
    return compilation
  })
}

function getContractName(output) {
  let { contracts } = output;
  if (contracts) {
    var name = Object.keys(contracts)[0];
    if (name) {
      let metadata;
      if (name.indexOf(':') != -1) {
        return name;
      } else {
        return Object.keys(contracts[name])[0];
      }
    }
  }
  return;
}

function getMetadata(output) {
  let { contracts } = output;
  if (contracts) {
    var name = Object.keys(contracts)[0];
    if (name) {
      let metadata;
      if (name.indexOf(':') != -1) {
        metadata = contracts[name].metadata;
      } else {
        let name2 = Object.keys(contracts[name])[0];
        metadata = (contracts[name])[name2].metadata;
      }
      metadata = JSON.parse(metadata);
      // console.log('=== metadata ===');
      // console.log(metadata);
      return metadata;
    }
  }
}

function format2(_output) {
  // console.log('output:');
  // console.log(_output);

  let output = {};
  output.contractName = getContractName(_output);
  output.success = output.contractName ? true : false;

  if (output.success) {
    output.metadata = getMetadata(_output);
    output.abi = output.metadata.output.abi;
    output.version = output.metadata.compiler.version;
  }

  output.errors = _output.errors;
  console.log('new output:');
  console.log(output);
  return output;
}
